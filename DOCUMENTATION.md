|Option|Purpose|Default Behavior|Example Usage|
| --- | --- | --- | --- |
|`licenseInclusionTest`|Limits which license types are included in the output. It is a function which takes the license type as string and returns a boolean (indicating whether or not the license type should be included)|All license types are included in the output.|`(licenseType) => (licenseType === 'MIT')`|
|`unacceptableLicenseTest`|Identifies which license types are unacceptable for the build. It is configured the same way as `licenseInclusionTest`.|No license type is marked as unacceptable.|See example usage for `licenseInclusionTest`.
|`handleUnacceptableLicense`|A function which gets called whenever an unacceptable license is encountered. It is passed the package name and license type.|Does not do anything|<code>(packageName, licenseType) => {<br>&nbsp;&nbsp;throw new Error(packageName + ' has unacceptable license type: ' + licenseType)<br>}</code>
|`handleMissingLicenseText`|A function which gets called whenever the license text cannot be found. It is passed the package name and license type. Its return value can be used to override the license text. |Does not do anything|<code>(packageName, licenseType) => {<br>&nbsp;&nbsp;console.log('Cannot find license for ' + packageName);<br>&nbsp;&nbsp;return 'UNKNOWN';<br>}</code>
|`perChunkOutput`|A boolean which controls whether or not the license notice is produced for each chunk or for the whole build.|Per chunk output is enabled.|`true`
|`licenseFilenames`|An array of strings indicating which filenames to search for when looking for a package's license file.|Searches for license files in this order: `LICENSE`, `LICENSE.md`, `LICENSE.txt`, `license`, `license.md`, `license.txt`|`['LICENSE']`
|`licenseTemplateDir`|Fallback license text based on license type, since some packages don't include a license file. This option specifies a directory containing `.txt` files containing the license text based on the license type. (e.g. `MIT.txt`). Templates can be found [here](https://github.com/spdx/license-list).|No template directory is used.|`'/path/to/license_templates'`
|`licenseTextOverrides`|Supply the license text for packages. Object whose keys are package names and values are strings to use for license text.|No overrides| <code>{<br>&nbsp;&nbsp;foopkg: 'abc'<br>}</code>
|`licenseTextOverrides`|Supply the license text file to use for packages. The file is resolved relative to the package directory. Object whose keys are package names and values are strings pointing to the file containing the license text.|No overrides| <code>{<br>&nbsp;&nbsp;foopkg: 'license-2.0.txt'<br>}</code>
|`renderLicenses`|Function to render the licenses. Output is a string. Input is an array of objects with the following keys:<ul><li>`packageJson` - the package.json of the package</li><li>`licenseId` - The license ID of the package. It is null if the license ID could not be determined.</li><li>`licenseText` - The text of the license. It is null if the license text could not be determined.</li></ul>|Plain text output of the package name, license ID, and license Text. Null values for license ID and license text are not printed.|<code>(modules) => {<br>&nbsp;&nbsp;console.log(modules[0].packageJson, modules[0].licenseId, modules[0].licenseText);<br>&nbsp;&nbsp;return JSON.stringify(modules);<br>}</code>
|`renderBanner`|Function to render the banner for `.js` files. No escaping is done on the output. Output is a string which should be in the form of a Javascript comment. Inputs are the generated filename of the license text output, and the list of packages as mentioned in the `renderLicenses` option.|A one line comment is generated pointing to the location of the license text output.|<code>(filename, modules) => {<br>&nbsp;&nbsp;console.log(modules);<br>&nbsp;&nbsp;return '/\*! licenses are at ' + filename + '*/';<br>}</code>
|`outputFilename`|Specifies filename template to use for the license text output.|`[name].licenses.txt`, where `[name]` refers the name of the webpack chunk being processed.|`'[name].[hash].licenses.txt'`
|`addBanner`|Boolean indicating wheter or not to add a banner indicating the path to the license text file to each `.js` file|The value is `true`, by default, meaning the banner will get written to each `.js` file.|`false`
|`chunkIncludeExcludeTest`|Include/exclude certain chunks. There are different ways to specify this option.<ol><li>An object indicating which chunks (string array) to include, via the `include` key, and which chunks to exclude via the `exclude` key.</li><li>Function that takes the chunk name as input and returns a boolean. If it returns `true` then the chunk is included.</li></ol>|All chunks are included.|<ol><li>`{ exclude: ['foo'] }`<br>or<br>`{ include: ['bar'] }`</li><li>`(chunkName) => chunkName.startsWith('my')`</li></ul>
|`buildRoot`|String specifying the path to the build root. (i.e. where the `package.json` of the actual project being built is.) This is useful in case there is some abstraction over webpack that makes the default behavior of guessing the build root impossible.|Guesses the root based on the information given by webpack.|`'/path/to/a/project/'`
|`modulesDirectories`|String array of modules directories to look inside. Used to scan directories besides `node_modules` for licenses.|Only `node_modules` is searched.|`['node_modules','other_modules']`
|`additionalChunkModules`|Add additional modules to add to a  chunk for license scanning. Modules need the `name` (name of the package) and `directory` (location of the installed package) key in order to work. Object whose keys are chunk names and values are arrays of modules.|No additional modules are added.|<code>{<br>&nbsp;&nbsp;main: [<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: 'somepkg'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directory: path.join(__dirname, 'node_modules', 'somepkg')<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;]<br>}</code>
|`additionalModules`|Array of modules (as mentioned in the `additionalChunkModules` option) to add to the license output. Useful in case `perChunkOutput` is set to `false`.|No additional modules are added.|<code>[<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: 'somepkg'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directory: path.join(__dirname, 'node_modules', 'somepkg')<br>&nbsp;&nbsp;}<br>]</code>
|`preferredLicenseTypes`|Array of strings specifying which license types should be preferred in case a package specifies multiple licenses via the deprecated |`licenses` field in its package.json|No preferred license types.|`['MIT', 'ISC']`
|`handleLicenseAmbiguity`|Function which is called whenever a license type could not be determined when a package uses the deprecated `licenses` field in its package.json. It should return the license type to use.|Prints a warning message to the console and chooses the first license type|<code>(packageName, licenses) => {<br>&nbsp;&nbsp;console.log(packageName);<br>&nbsp;&nbsp;console.log(licenses[0].url);<br>&nbsp;&nbsp;return licenses[0].type;<br>}</code>
|`handleMissingLicenseType`|Function which is called whenever a license type could not be found for a package. It is provided a package name and may output a license type, or null if no license type is to be used.|Prints a warning message to the console and assumes no license type exists for the package.|<code>(packageName) => {<br>&nbsp;&nbsp;console.log(packageName);<br>&nbsp;&nbsp;return null;<br>}</code>
|`excludedPackageTest`|Function which takes a package name as a string and returns a boolean. If it returns true then the package will be excluded.|No package is excluded.|<code>(packageName) => packageName === 'excluded-package'</code>